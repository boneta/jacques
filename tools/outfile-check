#!/usr/bin/env python3

# Description: Check missing values from an OUT file
# Last update: 03-05-2022

import argparse
import sys

import numpy as np

from jacques.dynnconfig import DynnConfig
from jacques.queues import QueueManager


if __name__ == '__main__':

    # parser
    parser = argparse.ArgumentParser(prog='check-missing-out',
                                     description='check missing values from an OUT file')
    parser.add_argument('o', metavar='.out', type=str, nargs='+',
                        help='output file from DYNAMON, combine if multiple')
    parser.add_argument('-n', metavar='#', type=int, nargs='+',
                        help='upper index extremes to check (def: 0-max)')
    parser.add_argument('-f', metavar='.dynn', type=str,
                        help='dynn configuration file to read index')
    parser.add_argument('-j', metavar='.job', type=str,
                        help='re-launch array of missing values from jobfile if any found')
    parser.add_argument('-s', metavar='.out', type=str,
                        help='sorted and min-to-zero output file')
    parser.add_argument('--dry', action='store_true',
                        help='dry run, print command but do not launch')
    args = parser.parse_args()

    out_files   = args.o
    ndx         = args.n
    dynn_file   = args.f
    job_file    = args.j
    sorted_file = args.s
    dry         = args.dry

    # read out files
    out_data_all = []
    for out in out_files:
        with open(out, 'r') as f:
            out_first_line = f.readline().strip()
            out_data_all.append(np.loadtxt(f, dtype=float, comments='#'))
    out_data = np.concatenate(out_data_all)

    # guess dimension (number of columns)
    #   X  #  DIST  Etot  Eqm  INDX  DIST_REF
    if out_data.shape[1] == 5:
        dim = 1
    elif out_data.shape[1] == 8:
        dim = 2
    else:
        sys.exit("ERROR: Inconsistent dimension of output file")

    # read dynn config file
    if dynn_file:
        dynn_config = DynnConfig(dynn_file)
        dynn_config.resolve_constr(dim)

    # remove duplicate index, sort data and find missing values
    if dim == 1:
        out_data = out_data[np.unique(out_data[:, 3], return_index=True)[1]]
        out_data = out_data[out_data[:, 3].argsort()]
        if ndx is not None:
            ndx = (0, ndx[0])
        elif dynn_file:
            ndx = (0, dynn_config.constr[0]['n'])
        else:
            ndx = (0, max(out_data[:, 3]))
        total_array = set(np.arange(ndx[0], ndx[1]+1))
        missing_array = total_array - set(out_data[:, 3])
        missing_array = [str(int(i)) for i in missing_array]
        missing_array.sort()
    elif dim == 2:
        out_data = out_data[np.unique(out_data[:, 4:6], axis=0, return_index=True)[1]]
        out_data = out_data[np.lexsort((out_data[:, 5], out_data[:, 4]))]
        if ndx is not None and len(ndx) >= 2:
            ndx = ((0, ndx[0]), (0, ndx[1]))
        elif dynn_file:
            ndx = ((0, dynn_config.constr[0]['n']), (0, dynn_config.constr[1]['n']))
        else:
            ndx = ((0, max(out_data[:, 4])), (0, max(out_data[:, 5])))
        total_array = {(i,j) for i in np.arange(ndx[0][0], ndx[0][1]+1) for j in np.arange(ndx[1][0], ndx[1][1]+1)}
        missing_array = total_array - {(i,j) for i,j in zip(out_data[:, 4], out_data[:, 5])}
        missing_array = [str(int(i))+' '+str(int(j)) for i,j in missing_array]
        missing_array.sort()

    if sorted_file is not None:
        # minimum energies to zero
        for i in [dim+0, dim+1]:
            out_data[:, i] -= min(out_data[:, i])
        # save sorted output file
        fmt = r'%12.4f  '*dim + r'%20.10f  %20.10f  ' + r'%5d  '*dim + r'%12.4f  '*dim
        np.savetxt(sorted_file, out_data, fmt=fmt, comments='#', header=out_first_line[1:])

    # print results and launch jobfile
    if len(missing_array) == 0:
        print("ALRIGHT! No missing values found")
    else:
        print("Missing {} values:\n {}".format(len(missing_array), '\n '.join(missing_array)))
        if job_file and dim == 1:
            qmanager = QueueManager()
            if qmanager.manager == 'slurm':
                qmanager.submit(job_file, f"--array={','.join(missing_array)}", dry)
            elif qmanager.manager == 'sge':
                for n in missing_array:
                    qmanager.submit(job_file, f"-t {n}-{n}", dry)
            else:
                sys.exit("ERROR: Could not launch. Queue manager not supported/found.")
